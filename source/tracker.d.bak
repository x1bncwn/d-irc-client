// source/tracker.d
module tracker;

import std.algorithm : canFind, countUntil;
import std.algorithm.mutation : remove;
import std.array : array;
import std.exception : enforce;
import std.format : format;
import std.string : toStringz, fromStringz, toUpper;
import std.stdio;

/// Mode prefix mapping and priority (higher = shown)
private immutable int[char] prefixPriority = [
    '@': 3,
    '+': 1,
    '%': 2,
    '&': 4,
    '~': 5
];

// Mode to prefix mapping
private immutable char[char] modeToPrefix = [
    'q': '~',
    'a': '&',
    'o': '@',
    'h': '%',
    'v': '+'
];

// Debug flag - set to false to disable verbose logging
private enum bool TRACKER_DEBUG = true;

/// Tracked user with ALL mode flags per channel
struct TrackedUser {
    string nick;
    string ident;
    string host;
    string realName;
    
    string[] channels;
    
    // channel -> array of ALL prefix chars user has in that channel
    char[][string] channelPrefixes;
    
    this(string nick, string ident = "", string host = "") {
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: Creating TrackedUser for nick='%s'", nick);
        }
        this.nick = nick;
        this.ident = ident;
        this.host = host;
    }
    
    /// Get highest priority prefix for display
    char getHighestPrefix(string channel) const {
        if (auto prefixesPtr = channel in channelPrefixes) {
            char highest = '\0';
            int highestPrio = 0;
            
            foreach (prefix; *prefixesPtr) {
                int prio = prefixPriority[prefix];
                if (prio > highestPrio) {
                    highest = prefix;
                    highestPrio = prio;
                }
            }
            
            return highest;
        }
        return '\0';
    }
    
    /// Check if user has a specific prefix in channel
    bool hasPrefix(string channel, char prefix) const {
        if (auto prefixesPtr = channel in channelPrefixes) {
            return canFind(*prefixesPtr, prefix);
        }
        return false;
    }
    
    /// Add a prefix to user in channel
    void addPrefix(string channel, char prefix) {
        if (!(channel in channelPrefixes)) {
            channelPrefixes[channel] = [];
        }
        
        if (!hasPrefix(channel, prefix)) {
            channelPrefixes[channel] ~= prefix;
        }
    }
    
    /// Remove a prefix from user in channel
    void removePrefix(string channel, char prefix) {
        if (auto prefixesPtr = channel in channelPrefixes) {
            // Dereference the pointer to get the array
            char[] prefixes = *prefixesPtr;
            
            // Manual filter - remove all occurrences of prefix
            char[] newPrefixes;
            foreach (p; prefixes) {
                if (p != prefix) {
                    newPrefixes ~= p;
                }
            }
            
            channelPrefixes[channel] = newPrefixes;
            
            // Clean up empty arrays
            if (newPrefixes.length == 0) {
                channelPrefixes.remove(channel);
            }
        }
    }
    
    /// Get all prefixes user has in channel (for debugging)
    char[] getAllPrefixes(string channel) const {
        if (auto prefixesPtr = channel in channelPrefixes) {
            return (*prefixesPtr).dup;
        }
        return [];
    }
    
    string toString() const {
        import std.format : format;
        return format("%s!%s@%s (%s)", nick, ident, host, channels);
    }
    
    static if (TRACKER_DEBUG) {
        /// Debug method to dump user state
        void dumpState() const {
            writefln("  User '%s' state:", nick);
            writefln("    Channels: %s", channels);
            writefln("    Prefixes:");
            foreach (chan, prefixes; channelPrefixes) {
                char highest = getHighestPrefix(chan);
                string prefixStr = prefixes.length > 0 ? format("%s", prefixes) : "none";
                writefln("      %s -> all: [%s], highest: '%c'", chan, prefixStr, highest);
            }
        }
    }
}

/// Tracked channel
struct TrackedChannel {
    string name;
    TrackedUser*[string] users;  // nick -> user pointer
    
    this(string name) {
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: Creating TrackedChannel '%s'", name);
        }
        this.name = name;
    }
    
    static if (TRACKER_DEBUG) {
        /// Debug method to dump channel state
        void dumpState() const {
            writefln("  Channel '%s' state:", name);
            writefln("    Users (%d total):", users.length);
            foreach (nick, userPtr; users) {
                writefln("      '%s' -> user exists: %s", nick, userPtr !is null);
            }
        }
    }
}

/// Main tracker class
class Tracker {
    private TrackedUser*[string] users;           // nick -> user
    private TrackedChannel[string] channels;      // channel -> channel
    private TrackedUser* selfUser;
    
    private bool tracking = false;
    
    this() {
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: ===== INSTANCE CONSTRUCTOR =====");
            writefln("TRACKER: Constructor called");
            writefln("TRACKER: Initial users count: %d", users.length);
            writefln("TRACKER: Initial channels count: %d", channels.length);
            writefln("TRACKER: ===== END INSTANCE CONSTRUCTOR =====");
        }
    }
    
    static if (TRACKER_DEBUG) {
        /// Debug method to dump entire tracker state
        void dumpState(string context = "") const {
            writefln("=== TRACKER STATE DUMP (%s) ===", context);
            writefln("Tracking: %s", tracking);
            writefln("Self user exists: %s", selfUser !is null);
            if (selfUser) {
                writefln("Self user nick: %s", selfUser.nick);
            }
            
            writefln("Total users: %d", users.length);
            writefln("Total channels: %d", channels.length);
            
            writefln("--- USERS ---");
            foreach (nick, userPtr; users) {
                auto user = *userPtr;
                writefln("User '%s':", nick);
                writefln("  Full info: %s", user.toString());
                writefln("  Channels: %s", user.channels);
                writefln("  Prefixes:");
                foreach (chan, prefixes; user.channelPrefixes) {
                    char highest = user.getHighestPrefix(chan);
                    string prefixStr = prefixes.length > 0 ? format("%s", prefixes) : "none";
                    writefln("    %s -> all: [%s], highest: '%c'", 
                             chan, prefixStr, highest);
                }
            }
            
            writefln("--- CHANNELS ---");
            foreach (chanName, chan; channels) {
                writefln("Channel '%s':", chanName);
                writefln("  Users in channel (%d):", chan.users.length);
                foreach (nick, userPtr; chan.users) {
                    writefln("    '%s' -> user exists: %s", nick, userPtr !is null);
                    if (userPtr) {
                        auto user = *userPtr;
                        char highest = user.getHighestPrefix(chanName);
                        writefln("      Highest prefix: %s",
                                 highest != '\0' ? format("'%c'", highest) : "none");
                    }
                }
            }
            writefln("=== END DUMP ===");
        }
    }
    
    /// Start tracking (call after connection)
    void start() {
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: start() called, tracking was: %s", tracking);
        }
        if (tracking) return;
        tracking = true;
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: tracking set to true");
            dumpState("after start()");
        }
    }
    
    /// Stop and clear all data
    void stop() {
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: stop() called");
            writefln("TRACKER: Before clearing - users: %d, channels: %d",
                     users.length, channels.length);
        }
        users = null;
        channels = null;
        selfUser = null;
        tracking = false;
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: After clearing - users: %d, channels: %d",
                     users.length, channels.length);
        }
    }
    
    /// Is currently tracking?
    bool isTracking() const @property {
        return tracking;
    }
    
    /// Find a channel (null if not in it)
    TrackedChannel* findChannel(string channel) {
        enforce(tracking, "Tracker not active");
        auto result = channel in channels;
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: findChannel('%s') -> %s", channel, result !is null);
        }
        return result;
    }
    
    /// Find a user by nick
    TrackedUser* findUser(string nick) {
        enforce(tracking, "Tracker not active");
        auto p = nick in users;
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: findUser('%s') -> %s", nick, p !is null);
        }
        return p ? *p : null;
    }
    
    /// Get highest prefix for user in channel ('\0' = none)
    char getPrefix(string channel, string nick) const {
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: ===== getPrefix ENTER =====");
            writefln("TRACKER: getPrefix called for nick='%s' in channel='%s'", nick, channel);
        }
        
        if (auto userPtr = nick in users) {
            auto user = *userPtr;
            char highest = user.getHighestPrefix(channel);
            
            static if (TRACKER_DEBUG) {
                if (highest != '\0') {
                    writefln("TRACKER: SUCCESS - Found highest prefix '%c' for '%s' in '%s'", 
                             highest, nick, channel);
                    writefln("TRACKER: All prefixes: [%s]", user.getAllPrefixes(channel));
                } else {
                    writefln("TRACKER: No prefix found for '%s' in '%s'", nick, channel);
                }
                writefln("TRACKER: ===== getPrefix EXIT =====");
            }
            
            return highest;
        } else {
            // Try case-insensitive search
            foreach (storedNick, userPtr; users) {
                if (toUpper(storedNick) == toUpper(nick)) {
                    auto user = *userPtr;
                    char highest = user.getHighestPrefix(channel);
                    
                    static if (TRACKER_DEBUG) {
                        if (highest != '\0') {
                            writefln("TRACKER: Found highest prefix '%c' via case-insensitive match", highest);
                        }
                        writefln("TRACKER: ===== getPrefix EXIT =====");
                    }
                    
                    return highest;
                }
            }
        }
        
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: No prefix found for '%s' in '%s'", nick, channel);
            writefln("TRACKER: ===== getPrefix EXIT =====");
        }
        
        return '\0';
    }
    
    // ==================== Event Handlers ====================
    
    void onSelfNick(string newNick) {
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: onSelfNick('%s')", newNick);
        }
        if (selfUser) {
            selfUser.nick = newNick;
        }
    }
    
    void onJoin(string channel, string nick, string ident = "", string host = "") {
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: ===== onJoin ENTER =====");
            writefln("TRACKER: onJoin('%s', '%s', '%s', '%s')", channel, nick, ident, host);
        }
        
        TrackedUser* user;
        bool isNewUser = false;
        
        if (selfUser && nick == selfUser.nick) {  // self join
            static if (TRACKER_DEBUG) {
                writefln("TRACKER: Self join detected");
            }
            user = selfUser;
        } else if (auto p = nick in users) {
            user = *p;
        } else {
            user = new TrackedUser(nick, ident, host);
            users[nick] = user;
            isNewUser = true;
        }
        
        if (!user.channels.canFind(channel)) {
            user.channels ~= channel;
        }
        
        if (channel !in channels) {
            channels[channel] = TrackedChannel(channel);
        }
        
        channels[channel].users[nick] = user;
        
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: ===== onJoin EXIT =====");
        }
    }
    
    void onNames(string channel, string[] nicks) {
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: ===== onNames ENTER =====");
            writefln("TRACKER: onNames called for channel='%s' with %d nicks", channel, nicks.length);
        }
        
        if (channel !in channels) {
            channels[channel] = TrackedChannel(channel);
        }
        
        foreach (rawNick; nicks) {
            // Strip prefix from NAMES (some servers send @nick, +nick)
            string nick = rawNick;
            char prefix = '\0';
            
            if (rawNick.length > 0) {
                char first = rawNick[0];
                // Check if first character is a known prefix
                auto ptr = first in prefixPriority;
                if (ptr !is null) {
                    prefix = first;
                    nick = rawNick[1..$];
                }
            }
            
            TrackedUser* user;
            if (auto p = nick in users) {
                user = *p;
            } else {
                user = new TrackedUser(nick);
                users[nick] = user;
            }
            
            if (!user.channels.canFind(channel)) {
                user.channels ~= channel;
            }
            
            channels[channel].users[nick] = user;
            
            // Apply prefix from NAMES if present
            if (prefix != '\0') {
                user.addPrefix(channel, prefix);
                static if (TRACKER_DEBUG) {
                    writefln("TRACKER: Added prefix '%c' from NAMES for '%s' in '%s'", 
                             prefix, nick, channel);
                }
            }
        }
        
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: ===== onNames EXIT =====");
        }
    }
    
    void onPart(string channel, string nick) {
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: onPart('%s', '%s')", channel, nick);
        }
        if (auto chan = channel in channels) {
            chan.users.remove(nick);
            
            if (auto userPtr = nick in users) {
                auto user = *userPtr;
                auto idx = user.channels.countUntil(channel);
                if (idx != -1) {
                    user.channels = user.channels.remove(idx);
                }
                
                // Remove all prefixes for this channel
                user.channelPrefixes.remove(channel);
                
                if (user.channels.length == 0 && user != selfUser) {
                    users.remove(nick);
                }
            }
            
            if (chan.users.length == 0) {
                channels.remove(channel);
            }
        }
    }
    
    void onQuit(string nick) {
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: onQuit('%s')", nick);
        }
        if (auto userPtr = nick in users) {
            auto user = *userPtr;
            foreach (chan; user.channels.dup) {
                onPart(chan, nick);
            }
        }
    }
    
    void onNickChange(string oldNick, string newNick) {
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: onNickChange('%s', '%s')", oldNick, newNick);
        }
        if (auto userPtr = oldNick in users) {
            auto user = *userPtr;
            users.remove(oldNick);
            user.nick = newNick;
            users[newNick] = user;
            
            if (user == selfUser) {
                selfUser = user;
            }
            
            foreach (chanName; user.channels) {
                if (auto chan = chanName in channels) {
                    chan.users.remove(oldNick);
                    chan.users[newNick] = user;
                }
            }
        }
    }
    
    void onMode(string channel, string modeStr, string[] params) {
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: ===== onMode ENTER =====");
            writefln("TRACKER: onMode('%s', '%s', %s)", channel, modeStr, params);
            writefln("TRACKER: Testing modeToPrefix lookups:");
            writefln("TRACKER:   ('q' in modeToPrefix) = %s", ('q' in modeToPrefix) !is null);
            writefln("TRACKER:   ('a' in modeToPrefix) = %s", ('a' in modeToPrefix) !is null);
            writefln("TRACKER:   ('o' in modeToPrefix) = %s", ('o' in modeToPrefix) !is null);
            writefln("TRACKER:   ('h' in modeToPrefix) = %s", ('h' in modeToPrefix) !is null);
            writefln("TRACKER:   ('v' in modeToPrefix) = %s", ('v' in modeToPrefix) !is null);
        }
        
        if (channel.length == 0 || channel[0] != '#') {
            static if (TRACKER_DEBUG) {
                writefln("TRACKER: Invalid channel, returning");
                writefln("TRACKER: ===== onMode EXIT =====");
            }
            return;
        }
        
        size_t paramIdx = 0;
        bool adding = true;
        
        foreach (char c; modeStr) {
            if (c == '+') { adding = true; continue; }
            if (c == '-') { adding = false; continue; }
            
            // Check if this is a prefix mode
            if (c in modeToPrefix) {
                char prefix = modeToPrefix[c];
                
                // Get target user
                string target;
                if (paramIdx < params.length) {
                    target = params[paramIdx];
                    paramIdx++;
                } else {
                    // No more parameters, use last one (for combined modes like -o+v x1bncwn)
                    if (params.length > 0) {
                        target = params[params.length - 1];
                        static if (TRACKER_DEBUG) {
                            writefln("TRACKER: Reusing last parameter '%s' for mode '%c'", target, c);
                        }
                    } else {
                        static if (TRACKER_DEBUG) {
                            writefln("TRACKER: No parameter for mode '%c', skipping", c);
                        }
                        continue;
                    }
                }
                
                static if (TRACKER_DEBUG) {
                    writefln("TRACKER: Processing mode '%c' -> prefix '%c' for target '%s' (adding=%s)", 
                             c, prefix, target, adding);
                }
                
                if (auto chan = channel in channels) {
                    if (auto userPtr = target in chan.users) {
                        auto user = *userPtr;
                        
                        if (adding) {
                            // Add the prefix
                            user.addPrefix(channel, prefix);
                            static if (TRACKER_DEBUG) {
                                writefln("TRACKER: ADDED prefix '%c' for '%s' in '%s'", 
                                         prefix, target, channel);
                                writefln("TRACKER: All prefixes now: [%s]", user.getAllPrefixes(channel));
                                writefln("TRACKER: Highest prefix now: '%c'", user.getHighestPrefix(channel));
                            }
                        } else {
                            // Remove the prefix
                            user.removePrefix(channel, prefix);
                            static if (TRACKER_DEBUG) {
                                writefln("TRACKER: REMOVED prefix '%c' for '%s' in '%s'", 
                                         prefix, target, channel);
                                writefln("TRACKER: All prefixes now: [%s]", user.getAllPrefixes(channel));
                                writefln("TRACKER: Highest prefix now: '%c'", user.getHighestPrefix(channel));
                            }
                        }
                    } else {
                        static if (TRACKER_DEBUG) {
                            writefln("TRACKER: User '%s' not found in channel '%s'", target, channel);
                        }
                    }
                } else {
                    static if (TRACKER_DEBUG) {
                        writefln("TRACKER: Channel '%s' not found", channel);
                    }
                }
            } else {
                // Non-prefix mode (like +b, +k, +l) - advance parameter index
                if (paramIdx < params.length) {
                    paramIdx++;
                }
                static if (TRACKER_DEBUG) {
                    writefln("TRACKER: Non-prefix mode '%c' (0x%02x)", c, c);
                }
            }
        }
        
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: ===== onMode EXIT =====");
        }
    }
    
    // Call when you know your own nick after connect
    void setSelfUser(string nick, string ident = "", string host = "") {
        static if (TRACKER_DEBUG) {
            writefln("TRACKER: setSelfUser('%s', '%s', '%s')", nick, ident, host);
        }
        selfUser = new TrackedUser(nick, ident, host);
        users[nick] = selfUser;
    }
}
