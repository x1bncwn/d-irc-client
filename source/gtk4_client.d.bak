// source/gtk_client.d
module gtk_client;

import gtk.application;
import gtk.application_window;
import gtk.scrolled_window;
import gtk.text_view;
import gtk.text_buffer;
import gtk.entry;
import gtk.tree_view;
import gtk.list_store;
import gtk.tree_iter;
import gtk.button;
import gtk.paned;
import gtk.box;
import gtk.label;
import gtk.tree_view_column;
import gtk.cell_renderer_text;
import gtk.separator;
import gtk.header_bar;
import gtk.popover_menu;
import gtk.window;
import gtk.types;

// For TextIter
import gtk.text_iter;

import gio.types;
import gio.menu;
import gio.simple_action;

import glib.variant;  // Will qualify to avoid conflict

import gobject.value;
import gtk.c.types;  // For g_type_string()

import std.concurrency;
import std.string;
import std.conv;
import core.time;
import core.thread;
import models;
import logging;
import irc_client;

class GTKClient {
    Application app;
    ApplicationWindow window;
    TextView textView;
    TextBuffer textBuffer;
    Entry inputEntry;
    TreeView channelList;
    ListStore channelStore;
    Box sidebar;
    Box mainBox;
    Paned hpaned;
    Tid ircTid;
    Tid guiTid;
    string currentDisplay;
    string currentServer;
    
    this() {
        logToTerminal("Initializing GTK application", "INFO", "main");
        app = new Application("org.example.dIRC", ApplicationFlags.FLAGS_NONE);
        currentDisplay = DEFAULT_SERVER;
        currentServer = DEFAULT_SERVER;
        
        app.connectActivate(delegate (Application app) {
            setupGui();
        });
    }
    
    void setupGui() {
        logToTerminal("Setting up GUI", "INFO", "main");
        
        window = new ApplicationWindow(app);
        window.setTitle("D IRC Client - GTK 4");
        window.setDefaultSize(1024, 768);
        
        mainBox = new Box(Orientation.Vertical, 0);
        
        auto headerBar = new HeaderBar();
        window.setTitlebar(headerBar);
        
        auto menuButton = new Button();
        menuButton.setIconName("open-menu-symbolic");
        headerBar.packStart(menuButton);
        
        auto menu = new Menu();
        menu.append("Connect", "app.connect");
        menu.append("Disconnect", "app.disconnect");
        
        // FIX 1: Try different PopoverMenu constructor
        auto popoverMenu = new PopoverMenu();
        popoverMenu.setMenuModel(menu);
        menuButton.setPopover(popoverMenu);
        
        hpaned = new Paned(Orientation.Horizontal);
        mainBox.append(hpaned);
        
        setupSidebar();
        setupChatArea();
        setupInputArea();
        
        window.setChild(mainBox);
        setupActions();
        setupSignals();
        
        guiTid = thisTid;
        spawn(&messageLoop);
        send(thisTid, thisTid);
        
        setupGuiUpdateLoop();
        window.present();
    }
    
    void setupSidebar() {
        sidebar = new Box(Orientation.Vertical, 5);
        sidebar.setMarginStart(5);
        sidebar.setMarginEnd(5);
        sidebar.setMarginTop(5);
        sidebar.setMarginBottom(5);
        
        auto sidebarLabel = new Label("Channels");
        sidebarLabel.setHalign(Align.Start);
        sidebar.append(sidebarLabel);
        
        auto separator = new Separator(Orientation.Horizontal);
        sidebar.append(separator);
        
        // FIX 2: Use g_type_string() function, not G_TYPE_STRING constant
        channelStore = new ListStore(1, [g_type_string()]);
        channelList = new TreeView();
        channelList.setModel(channelStore);
        
        TreeIter iter;
        channelStore.append(iter);
        
        // FIX 2: Use g_type_string() function
        Value val = new Value(g_type_string());
        val.setString(DEFAULT_SERVER);
        channelStore.setValue(iter, 0, val);
        
        auto renderer = new CellRendererText();
        auto column = new TreeViewColumn();
        column.setTitle("Channels");
        column.packStart(renderer, true);
        column.addAttribute(renderer, "text", 0);
        channelList.appendColumn(column);
        
        auto scrolledSidebar = new ScrolledWindow();
        
        // FIX 3: Use setPolicy (camelCase) not set_policy
        scrolledSidebar.setPolicy(PolicyType.Automatic, PolicyType.Automatic);
        
        scrolledSidebar.setChild(channelList);
        sidebar.append(scrolledSidebar);
        
        hpaned.setStartChild(sidebar);
    }
    
    void setupChatArea() {
        auto chatBox = new Box(Orientation.Vertical, 5);
        chatBox.setMarginStart(5);
        chatBox.setMarginEnd(5);
        chatBox.setMarginTop(5);
        chatBox.setMarginBottom(5);
        
        textView = new TextView();
        textBuffer = new TextBuffer(null);
        textView.setBuffer(textBuffer);
        textView.setEditable(false);
        textView.setWrapMode(WrapMode.Word);
        
        auto scrolledChat = new ScrolledWindow();
        
        // FIX 3: Use setPolicy (camelCase)
        scrolledChat.setPolicy(PolicyType.Automatic, PolicyType.Automatic);
        
        scrolledChat.setChild(textView);
        chatBox.append(scrolledChat);
        
        hpaned.setEndChild(chatBox);
    }
    
    void setupInputArea() {
        auto inputBox = new Box(Orientation.Horizontal, 5);
        inputBox.setMarginStart(5);
        inputBox.setMarginEnd(5);
        inputBox.setMarginBottom(5);
        
        inputEntry = new Entry();
        inputEntry.setHexpand(true);
        inputEntry.setPlaceholderText("Type message or command...");
        
        auto sendButton = new Button();
        sendButton.setLabel("Send");
        
        inputBox.append(inputEntry);
        inputBox.append(sendButton);
        mainBox.append(inputBox);
        
        sendButton.connectClicked(delegate (Button button) {
            sendMessage();
        });
    }
    
    void setupActions() {
        auto connectAction = new SimpleAction("connect", null);
        
        // FIX 4: Use fully qualified glib.variant.Variant
        connectAction.connectActivate(delegate (SimpleAction action, glib.variant.Variant parameter) {
            logToTerminal("Connect action triggered", "INFO", "main");
            spawn(&runIrcServer, DEFAULT_SERVER, thisTid);
            ircTid = thisTid;
        });
        
        app.addAction(connectAction);
        
        auto disconnectAction = new SimpleAction("disconnect", null);
        disconnectAction.connectActivate(delegate (SimpleAction action, glib.variant.Variant parameter) {
            logToTerminal("Disconnect action triggered", "INFO", "main");
        });
        
        app.addAction(disconnectAction);
    }
    
    void setupSignals() {
        inputEntry.connectActivate(delegate (Entry entry) {
            sendMessage();
        });
        
        auto selection = channelList.getSelection();
        
        // FIX 5: The parameter is just the selection object, not TreeSelection type
        selection.connectChanged(delegate {
            TreeModel model;
            TreeIter iter;
            if (selection.getSelected(model, iter)) {
                Value val = new Value(g_type_string());
                channelStore.getValue(iter, 0, val);
                string channel = val.getString();
                currentDisplay = channel;
                logToTerminal("Selected channel: " ~ currentDisplay, "INFO", "main");
                textBuffer.setText("");
            }
        });
        
        window.connectCloseRequest(delegate (Window window) {
            logToTerminal("Close request received", "INFO", "main");
            app.quit();
            return true;
        });
    }
    
    void setupGuiUpdateLoop() {
        // FIX 6: Correct spawn syntax
        spawn({
            while (true) {
                Thread.sleep(100.msecs);
                receiveTimeout(Duration.zero,
                    (IRCMessage msg) {
                        if (msg.type == IRCMessage.Type.Message) {
                            appendChatMessage(msg.channel, msg.text);
                        } else if (msg.type == IRCMessage.Type.UpdateChannels) {
                            updateChannelList(msg.channel, msg.action);
                        }
                    }
                );
            }
        });
    }
    
    void sendMessage() {
        auto text = inputEntry.getText();
        inputEntry.setText("");
        if (text.length == 0) return;
        
        logToTerminal("User input: " ~ text, "INFO", "main");
        
        if (text.startsWith("/connect ")) {
            auto server = text["/connect ".length .. $];
            spawn(&runIrcServer, server.strip(), thisTid);
            ircTid = thisTid;
        } else if (text.startsWith("/join ")) {
            auto channel = text["/join ".length .. $];
            send(ircTid, IRCMessage(IRCMessage.Type.UpdateChannels, channel.strip(), "", "join"));
        } else if (text.startsWith("/part ")) {
            auto channel = text["/part ".length .. $];
            send(ircTid, IRCMessage(IRCMessage.Type.UpdateChannels, channel.strip(), "", "part"));
        } else {
            send(ircTid, IRCMessage(IRCMessage.Type.Message, currentDisplay, 
                  "[" ~ currentDisplay ~ "] " ~ DEFAULT_NICK ~ ": " ~ text));
        }
    }
    
    void appendChatMessage(string channel, string message) {
        logToTerminal("Appending message to channel " ~ channel ~ ": " ~ message, "INFO", "main");
        
        if (channel == currentDisplay) {
            // FIX 7: TextIter is available from gtk.text_iter import
            TextIter endIter;
            textBuffer.getEndIter(endIter);
            textBuffer.insert(endIter, message ~ "\n");
        }
    }
    
    void updateChannelList(string channel, string action) {
        logToTerminal("Updating channel list: " ~ channel ~ " " ~ action, "INFO", "main");
        
        if (action == "join") {
            TreeIter iter;
            channelStore.append(iter);
            
            Value val = new Value(g_type_string());
            val.setString(channel);
            channelStore.setValue(iter, 0, val);
            
            currentDisplay = channel;
        } else if (action == "part" || action == "failed") {
            TreeIter iter;
            bool valid = channelStore.getIterFirst(iter);
            
            while (valid) {
                Value val = new Value(g_type_string());
                channelStore.getValue(iter, 0, val);
                string storedChannel = val.getString();
                
                if (storedChannel == channel) {
                    channelStore.remove(iter);
                    break;
                }
                valid = channelStore.iterNext(iter);
            }
            
            currentDisplay = DEFAULT_SERVER;
            textBuffer.setText("");
        }
    }
    
    void run() {
        app.run([]);
    }
}

private @trusted void messageLoop() {
    Tid guiTid = receiveOnly!Tid();
    while (true) {
        receive(
            (IRCMessage msg) {
                logToTerminal("Received IRC message: " ~ msg.to!string, "INFO", "msg_loop");
                send(guiTid, msg);
            }
        );
    }
}
