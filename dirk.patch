diff -uNr dirk/0.2.0/dirk/irc/client.d dirk/0.2.0/dirk/irc/client.d
--- dirk/0.2.0/dirk/irc/client.d	2015-10-30 03:29:50.000000000 -0400
+++ dirk/0.2.0/dirk/irc/client.d	2025-12-21 20:57:39.972264707 -0500
@@ -16,15 +16,17 @@
 import std.array;
 import std.range;
 import std.regex; // TEMP: For EOL identification
-import std.string : format, indexOf, sformat, munch;
+import std.string : format, indexOf, sformat;
 import std.traits;
 import std.typetuple;
+import std.typecons : isTuple;
 import std.utf : byChar;
 
 //debug=Dirk;
 debug(Dirk) static import std.stdio;
 debug(Dirk) import std.conv;
 
+
 // Not using standard library because of auto-decoding issues
 private size_t indexOfNewline(in char[] haystack) pure nothrow @safe @nogc
 {
@@ -162,7 +164,7 @@
 	 */
 	void connect(Address serverAddress, in char[] password)
 	{
-		enforceEx!UnconnectedClientException(!connected, "IrcClient is already connected");
+		enforce(!connected, new UnconnectedClientException("IrcClient is already connected"));
 
 		socket.connect(serverAddress);
 
@@ -192,7 +194,7 @@
 	 */
 	bool read()
 	{
-		enforceEx!UnconnectedClientException(connected, "cannot read from unconnected IrcClient");
+		enforce(connected, new UnconnectedClientException("cannot read from unconnected IrcClient"));
 
 		while(connected)
 		{
@@ -240,7 +242,7 @@
 	{
 		import std.format : formattedWrite;
 
-		enforceEx!UnconnectedClientException(connected, "cannot write to unconnected IrcClient");
+		enforce(connected, new UnconnectedClientException("cannot write to unconnected IrcClient"));
 
 		char[512] formatBuffer = void;
 
@@ -266,7 +268,7 @@
 	/// Ditto
 	void writef(in char[] rawline)
 	{
-		enforceEx!UnconnectedClientException(connected, "cannot write to unconnected IrcClient");
+		enforce(connected, new UnconnectedClientException("cannot wtite to unconnected IrcClient"));
 		socket.send(rawline[0 .. min($, 510)]);
 		socket.send("\r\n");
 	}
diff -uNr dirk/0.2.0/dirk/irc/dcc.d dirk/0.2.0/dirk/irc/dcc.d
--- dirk/0.2.0/dirk/irc/dcc.d	2015-10-30 03:29:50.000000000 -0400
+++ dirk/0.2.0/dirk/irc/dcc.d	2025-12-21 15:36:07.736888294 -0500
@@ -4,6 +4,7 @@
 import std.array;
 import std.exception;
 import std.random : uniform;
+import std.format : format;
 import std.range;
 import std.socket;
 import std.typecons;
diff -uNr dirk/0.2.0/dirk/irc/eventloop.d dirk/0.2.0/dirk/irc/eventloop.d
--- dirk/0.2.0/dirk/irc/eventloop.d	2015-10-30 03:29:50.000000000 -0400
+++ dirk/0.2.0/dirk/irc/eventloop.d	2025-12-21 15:34:33.908888330 -0500
@@ -157,8 +157,7 @@
 	 */
 	void add(IrcClient client)
 	{
-		enforceEx!UnconnectedClientException(
-		    client.connected, "client to be added must be connected");
+		enforce(client.connected, new UnconnectedClientException("client to be added must be connected"));
 
 		if(client in watchers)
 			return;
@@ -406,4 +405,4 @@
 	{
 		ev_run(ev, 0);
 	}
-}
\ No newline at end of file
+}
diff -uNr dirk/0.2.0/dirk/irc/linebuffer.d dirk/0.2.0/dirk/irc/linebuffer.d
--- dirk/0.2.0/dirk/irc/linebuffer.d	2015-10-30 03:29:50.000000000 -0400
+++ dirk/0.2.0/dirk/irc/linebuffer.d	2025-12-21 15:28:23.600888471 -0500
@@ -68,7 +68,7 @@
 	private:
 	size_t moveDown()
 	{
-		enforceEx!IrcParseErrorException(lineStart != 0, "line too long for buffer");
+		enforce(lineStart != 0, new IrcParseErrorException("line too long for buffer"));
 
 		auto length = bufferPos - lineStart;
 		memmove(buffer.ptr, buffer.ptr + lineStart, length);
diff -uNr dirk/0.2.0/dirk/irc/protocol.d dirk/0.2.0/dirk/irc/protocol.d
--- dirk/0.2.0/dirk/irc/protocol.d	2015-10-30 03:29:50.000000000 -0400
+++ dirk/0.2.0/dirk/irc/protocol.d	2025-12-21 15:59:43.032887754 -0500
@@ -1,6 +1,7 @@
 module irc.protocol;
 
 import irc.exception;
+import irc.util : munch;
 
 import std.algorithm;
 import std.array;
@@ -60,7 +61,7 @@
 	///
 	const(char)[] command;
 	///
-	const(char)[][] arguments() @property pure nothrow @nogc
+	const(char)[][] arguments() @property pure nothrow @nogc return
 	{
 		return argumentBuffer[0 .. numArguments];
 	}
diff -uNr dirk/0.2.0/dirk/irc/tracker.d dirk/0.2.0/dirk/irc/tracker.d
--- dirk/0.2.0/dirk/irc/tracker.d	2015-10-30 03:29:50.000000000 -0400
+++ dirk/0.2.0/dirk/irc/tracker.d	2025-12-21 15:32:01.804888388 -0500
@@ -4,9 +4,9 @@
 import irc.client;
 import irc.util : ExceptionConstructor;
 
-import std.exception : enforceEx;
 import std.traits : Unqual;
 import std.typetuple : TypeTuple;
+import std.exception : enforce;
 
 ///
 class IrcTrackingException : Exception
@@ -457,7 +457,7 @@
 	auto channels() @property
 	{
 		import std.range : takeExactly;
-		enforceEx!IrcTrackingException(_isTracking, "not currently tracking");
+		enforce(_isTracking == State.enabled, new IrcTrackingException("not currently tracking"));
 		return _channels.byValue.takeExactly(_channels.length);
 	}
 
@@ -482,7 +482,7 @@
 	{
 		import std.algorithm : map;
 		import std.range : takeExactly;
-		enforceEx!IrcTrackingException(_isTracking, "not currently tracking");
+		enforce(_isTracking == State.enabled, new IrcTrackingException("not currently tracking"));
 		return _users.byValue.takeExactly(_users.length);
 	}
 
@@ -508,7 +508,7 @@
 	 */
 	CustomTrackedChannel!Payload* findChannel(in char[] channelName)
 	{
-		enforceEx!IrcTrackingException(_isTracking, "not currently tracking");
+		enforce(_isTracking == State.enabled, new IrcTrackingException("not currently tracking"));
 		return channelName in _channels;
 	}
 
@@ -527,7 +527,7 @@
 	 */
 	CustomTrackedUser!Payload* findUser(in char[] nickName)
 	{
-		enforceEx!IrcTrackingException(_isTracking, "not currently tracking");
+		enforce(_isTracking == State.enabled, new IrcTrackingException("not currently tracking"));
 		if(auto user = nickName in _users)
 			return *user;
 		else
@@ -589,7 +589,7 @@
 	 */
 	CustomTrackedUser!Payload* opBinary(string op : "in")(in char[] nick)
 	{
-		enforceEx!IrcTrackingException(cast(bool)this, "the TrackedChannel is invalid");
+		enforce(this._name !is null, new IrcTrackingException("the TrackedChannel is invalid"));
 		if(auto pUser = nick in _users)
 			return *pUser;
 		else
diff -uNr dirk/0.2.0/dirk/irc/util.d dirk/0.2.0/dirk/irc/util.d
--- dirk/0.2.0/dirk/irc/util.d	2015-10-30 03:29:50.000000000 -0400
+++ dirk/0.2.0/dirk/irc/util.d	2025-12-21 15:59:02.276887770 -0500
@@ -109,3 +109,13 @@
 		super(msg, file, line, next);
 	}
 }
+
+// Manual munch implementation (std.string.munch was removed)
+public inout(char)[] munch(inout(char)[] haystack, in char[] pattern) pure @safe @nogc
+{
+    size_t i = 0;
+    size_t j = 0;                                                                                                                                             while (i < haystack.length && j < pattern.length) {                              if (haystack[i] != pattern[j]) {
+            break;                                                                   }                                                                            i++;                                                                         j++;                                                                     }                                                                                                                                                         auto result = haystack[0..i];
+    haystack = haystack[i..$];
+    return result;                                                           }
+
diff -uNr dirk/0.2.0/dirk/ssl/socket.d dirk/0.2.0/dirk/ssl/socket.d
--- dirk/0.2.0/dirk/ssl/socket.d	2015-10-30 03:29:50.000000000 -0400
+++ dirk/0.2.0/dirk/ssl/socket.d	2025-12-21 16:01:31.716887713 -0500
@@ -7,20 +7,20 @@
 
 version(force_ssl_load) shared static this()
 {
-	loadOpenSSL();
+        loadOpenSSL();
 }
 
 private SSL_CTX* sslContext;
 
 void initSslContext()
 {
-	if(!sslContext)
-		sslContext = SSL_CTX_new_p(SSLv3_client_method_p());
+        if(!sslContext)
+                sslContext = SSL_CTX_new_p(SSLv3_client_method_p());
 }
 
 version(force_ssl_load) static this()
 {
-	initSslContext();
+        initSslContext();
 }
 
 /**
@@ -28,56 +28,63 @@
 */
 class SslSocket : Socket
 {
-	private:
-	SSL* ssl;
+        private:
+        SSL* ssl;
 
-	public:
-	/**
-	* Create a new unconnected and blocking SSL socket.
-	* See_Also:
-	*   $(DPREF client, IrcClient.this)
-	*/
-	this(AddressFamily af)
-	{
-		loadOpenSSL();
-		initSslContext();
-
-		super(af, SocketType.STREAM, ProtocolType.TCP);
-
-		ssl = SSL_new_p(sslContext);
-		SSL_set_fd_p(ssl, super.handle);
-		SSL_set_verify_p(ssl, SSL_VERIFY_NONE, null);
-	}
-
-	override:
-	void connect(Address to) @trusted
-	{
-		super.connect(to);
-		sslEnforce(ssl, SSL_connect_p(ssl));
-	}
-
-	ptrdiff_t receive(void[] buf)
-	{
-		return receive(buf, SocketFlags.NONE);
-	}
-
-	ptrdiff_t receive(void[] buf, SocketFlags flags) @trusted
-	{
-		auto result = sslEnforce(ssl, SSL_read_p(ssl, buf.ptr, cast(int)buf.length));
-		return cast(ptrdiff_t)result;
-	}
-
-	ptrdiff_t send(const(void)[] buf)
-	{
-		return send(buf, SocketFlags.NONE);
-	}
-
-	ptrdiff_t send(const(void)[] buf, SocketFlags flags) @trusted
-	{
-		auto result = sslEnforce(ssl, SSL_write_p(ssl, buf.ptr, cast(int)buf.length));
-		return cast(ptrdiff_t)result;
-	}
+        public:
+        /**
+        * Create a new unconnected and blocking SSL socket.
+        * See_Also:
+        *   $(DPREF client, IrcClient.this)
+        */
+        this(AddressFamily af)
+        {
+                loadOpenSSL();
+                initSslContext();
+
+                super(af, SocketType.STREAM, ProtocolType.TCP);
+
+                ssl = SSL_new_p(sslContext);
+                SSL_set_fd_p(ssl, super.handle);
+                SSL_set_verify_p(ssl, SSL_VERIFY_NONE, null);
+        }
+
+        override:
+        void connect(Address to)
+        {
+                super.connect(to);
+                () @trusted {
+                        sslEnforce(ssl, SSL_connect_p(ssl));
+                }();
+        }
+
+        // Expose base class send method
+        alias send = Socket.send;
+        
+        // Override send with SSL version
+        override ptrdiff_t send(scope const(void)[] buf, SocketFlags flags = cast(SocketFlags)0)
+        {
+                int result;
+                () @trusted {
+                        result = SSL_write_p(ssl, &buf[0], cast(int)buf.length);
+                        sslEnforce(ssl, result);
+                }();
+                return cast(ptrdiff_t)result;
+        }
+
+        // Expose base class receive method
+        alias receive = Socket.receive;
+        
+        // Override receive with SSL version
+        override ptrdiff_t receive(scope void[] buf, SocketFlags flags = cast(SocketFlags)0)
+        {
+                int result;
+                () @trusted {
+                        result = SSL_read_p(ssl, &buf[0], cast(int)buf.length);
+                        sslEnforce(ssl, result);
+                }();
+                return cast(ptrdiff_t)result;
+        }
 
-	// TODO: What about sendTo? Throwing stub?
+        // TODO: What about sendTo? Throwing stub?
 }
-
